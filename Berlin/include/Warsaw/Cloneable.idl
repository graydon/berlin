/*$Id: Cloneable.idl,v 1.7 1999/09/10 20:57:37 gray Exp $
 *
 * This source file is a part of the Berlin Project.
 * Copyright (C) 1998 Graydon Hoare <graydon@pobox.com> 
 * http://www.berlin-consortium.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
 * MA 02139, USA.
 */
#ifndef _Cloneable_idl
#define _Cloneable_idl

#include "LifeCycle.idl"

interface ServerContext;

interface Cloneable : ::CosLifeCycle::LifeCycleObject
//. ths cloneable interface is the base type for most of the objects
//. you will allocate in a berlin server. It is an extended form of
//. lifecycle object which supports a few extra convenience methods
//. such as hot-swapping and reference counting (since many resources
//. are shared in berlin)
{
  void bind(in ServerContext sc);
  // these are used by the various parenting operations of container
  // objects, to indicate when a cloneable should be freed and when
  // it's still in use somewhere inside the server. They usually
  // delegate to a singleton map somewhere in the server
  // implementation. The important thing to note is that there is no
  // complex mark/sweep collector at work here. You have to put
  // clones into a strict DAG if you ever want the GC to reap them.
  void reference();
  void forget();
  
  // clone reproduces this object on this server. It doesn't remove
  // the current object
  Cloneable clone();
  
  // reload replaces this object with a freshly created copy,
  // reloaded from disk.  you don't notice the change,
  // hopefully. All your references to the old object should be
  // transparently redirected via lifecycle service to the new
  // object.
  void reload();
};

#endif
